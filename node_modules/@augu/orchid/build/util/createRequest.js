"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const HttpRequest_1 = __importDefault(require("../HttpRequest"));
const getOption_1 = __importDefault(require("./getOption"));
const url_1 = require("url");
const merge_1 = __importDefault(require("./merge"));
/**
 * Functions to create a Request
 * @param url The URL of the request
 * @param method The method of the request
 * @param options The options used
 * @returns The http request
 */
function createRequest(url, method, options) {
    if ((typeof url === 'string' || url instanceof url_1.URL) && options === undefined) {
        let newUrl = url;
        if (this.defaults !== null) {
            if (this.defaults.hasOwnProperty('baseUrl')) {
                if (url instanceof url_1.URL)
                    newUrl = new url_1.URL(url.pathname, this.defaults.baseUrl);
                else if (typeof url === 'string')
                    newUrl = new url_1.URL(`${this.defaults.baseUrl}${url.startsWith('/') ? url : `/${url}`}`);
                else
                    throw new TypeError(`Expected "string" or URL (package: 'url') but gotten ${typeof url}`);
            }
        }
        return new HttpRequest_1.default(this, { method, url: newUrl });
    }
    else if ((typeof url === 'string' || url instanceof url_1.URL) && options !== undefined) {
        if (this.defaults !== null) {
            options = merge_1.default(options, {
                followRedirects: getOption_1.default('followRedirects', false, this.defaults),
                headers: getOption_1.default('headers', {}, this.defaults),
                timeout: getOption_1.default('timeout', 30000, this.defaults)
            });
            if (this.defaults.baseUrl !== undefined) {
                if (url instanceof url_1.URL) {
                    options.url = new url_1.URL(url.pathname, this.defaults.baseUrl);
                }
                else if (typeof url === 'string') {
                    options.url = new url_1.URL(`${this.defaults.baseUrl}${url.startsWith('/') ? url : `/${url}`}`);
                }
                else {
                    throw new TypeError(`Expected "string" or URL (package: 'url') but gotten ${typeof url}`);
                }
            }
        }
        return new HttpRequest_1.default(this, { method, ...options });
    }
    else if (!(url instanceof url_1.URL) && url instanceof Object && options === undefined) {
        if (this.defaults !== null) {
            const opts = merge_1.default(url, {
                followRedirects: getOption_1.default('followRedirects', false, this.defaults),
                headers: getOption_1.default('headers', {}, this.defaults),
                timeout: getOption_1.default('timeout', 30000, this.defaults)
            });
            if (this.defaults.baseUrl !== undefined) {
                if (opts.url instanceof url_1.URL) {
                    opts.url = new url_1.URL(opts.url.pathname, this.defaults.baseUrl);
                }
                else if (typeof opts.url === 'string') {
                    opts.url = new url_1.URL(`${this.defaults.baseUrl}${opts.url.startsWith('/') ? opts.url : `/${opts.url}`}`);
                }
                else {
                    throw new TypeError(`Expected "string" or URL (package: 'url') but gotten ${typeof opts.url}`);
                }
            }
        }
        return new HttpRequest_1.default(this, { method, ...url });
    }
    else if (url instanceof Object && options !== undefined) {
        throw new TypeError('Parameter `options` shouldn\'t be added in');
    }
    else {
        throw new TypeError(`Expecting 'string', RequestOptions, or an instanceof URL but gotten ${typeof url} (options: ${typeof options})`);
    }
}
exports.default = createRequest;
