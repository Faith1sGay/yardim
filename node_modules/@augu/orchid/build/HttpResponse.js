"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = require("http");
const HttpError_1 = __importDefault(require("./errors/HttpError"));
const Blob_1 = __importDefault(require("./internals/Blob"));
class HttpResponse {
    constructor(core, isStreaming, canBlob) {
        this.canBlob = canBlob;
        this.shouldStream = isStreaming;
        this.statusCode = core.statusCode ? core.statusCode : 200;
        this.headers = core.headers;
        this.core = core;
        this.body = Buffer.alloc(0);
    }
    /** If the response is successful or not */
    get successful() {
        return this.statusCode >= 200 || this.statusCode < 300;
    }
    /** Returns a prettified version of the status */
    get status() {
        return `${this.statusCode} ${http_1.STATUS_CODES[this.statusCode]}`;
    }
    /** Returns if the body of the response is empty */
    get isEmpty() {
        return this.body.length === 0;
    }
    /**
     * Sets the encoding of the response
     * @param encoding The encoding to set
     */
    setEncoding(encoding) {
        this.core.setEncoding(encoding);
        return this;
    }
    /**
     * Adds a chunk to the body
     * @param chunk The chunk to add
     */
    addChunk(chunk) {
        this.body = Buffer.concat([this.body, chunk]);
    }
    /**
     * Turns the body into a JSON response
     * @returns The response as the typed object
     */
    json() {
        try {
            return JSON.parse(this.body.toString());
        }
        catch {
            throw new HttpError_1.default(1006, 'Unable to parse body into a JSON structure');
        }
    }
    /**
     * Turns the body into a string
     * @returns The text itself
     */
    text() {
        return this.body.toString();
    }
    /**
     * Returns the raw buffer
     * @returns The buffer itself
     */
    raw() {
        return this.body;
    }
    /**
     * Returns a Blob of the response
     */
    blob() {
        if (!this.canBlob)
            throw new Error('Missing `blob` middleware');
        return new Blob_1.default([this.raw()], this.headers.hasOwnProperty('content-type') ? { type: this.headers['content-type'] } : { type: '' });
    }
    /**
     * Returns the HTTP stream or the zlib stream if data was compressed
     * @returns {IncomingMessage | zlib.Deflate | zlib.Gunzip} Returns the following:
     * - **IncomingMessage**: Nothing was changed, i.e HttpRequest#compress wasn't called
     * - **zlib.Deflate**: Returns the deflate that zlib has used
     * - **zlib.Gunzip**: Returns a deflate but gun-zipped
     */
    stream() {
        if (!this.shouldStream)
            throw new Error('You didn\'t make this request into a Streamable object');
        return this.core; // This is a stream, yes it is
    }
    /**
     * Pipes anything to this [Response] instance
     * @param item The item to use Stream.pipe in
     * @param options The options to use
     * @returns That stream's instance
     */
    pipe(item, options) {
        return this.core.pipe(item, options);
    }
}
exports.default = HttpResponse;
