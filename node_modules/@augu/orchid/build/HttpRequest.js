"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const TimeoutError_1 = __importDefault(require("./errors/TimeoutError"));
const middleware_1 = require("./middleware");
const HttpResponse_1 = __importDefault(require("./HttpResponse"));
const HttpError_1 = __importDefault(require("./errors/HttpError"));
const form_data_1 = __importDefault(require("form-data"));
const url_1 = require("url");
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const zlib_1 = __importDefault(require("zlib"));
const Blob_1 = __importDefault(require("./internals/Blob"));
function isUppercase(text) {
    const upper = text.toUpperCase();
    return text === upper;
}
function figureData(packet) {
    if (typeof packet === 'string')
        return packet;
    if (packet instanceof Object)
        return packet;
    if (packet instanceof Buffer)
        return packet;
    if (packet instanceof Blob_1.default)
        return packet.raw();
    if (packet instanceof form_data_1.default) {
        if (!this._has('form'))
            throw new Error('Missing "forms" middleware');
        if (!this.headers.hasOwnProperty('content-type'))
            this.headers['content-length'] = Buffer.byteLength(packet.getBuffer());
        return packet.getBuffer();
    }
}
function isCorrectUrl(data) {
    if (typeof data === 'string')
        return true;
    if (data instanceof url_1.URL)
        return true;
    return false;
}
function isObject(data) {
    return data !== undefined
        && data !== null
        && typeof data === 'object'
        && !Array.isArray(data);
}
class HttpRequest {
    /**
     * Creates a new HTTP request
     * @param {HttpClient} client The client
     * @param {RequestOptions} options The options to use
     */
    constructor(client, options) {
        if (!isCorrectUrl(options.url))
            throw new Error('Malformed URL; must be `string` or `URL` (package: "url")');
        this.followRedirects = options.hasOwnProperty('followRedirects') ? options.followRedirects : false;
        this.compressData = options.hasOwnProperty('compress') ? options.compress : false;
        this.streaming = options.hasOwnProperty('stream') ? options.stream : false;
        this.headers = options.hasOwnProperty('headers') ? options.headers : {};
        this.timeout = options.hasOwnProperty('timeout') ? options.timeout : null;
        this.client = client;
        this.method = options.method ? isUppercase(options.method) ? options.method.toLowerCase() : options.method : 'GET';
        this.data = options.hasOwnProperty('data') ? figureData.call(this, options.data) : null;
        this.url = options.url instanceof url_1.URL ? options.url : new url_1.URL(options.url);
    }
    _has(name) {
        return this.client.middleware.has(name);
    }
    /**
     * Make this request into a stream (must add the Streams middleware or it'll error!)
     * @returns This instance to chain methods
     */
    stream() {
        if (!this.client.middleware.has('stream'))
            throw new Error('Missing the Stream middleware');
        this.streaming = true;
        return this;
    }
    /**
     * Make this request compress data (must add the Compress middleware)
     * @returns This instance to chain methods
     */
    compress() {
        if (!this.client.middleware.has('compress'))
            throw new Error('Missing the Compress Data middleware');
        if (!this.headers.hasOwnProperty('accept-encoding'))
            this.headers['accept-encoding'] = 'gzip, deflate';
        this.compressData = true;
        return this;
    }
    /**
     * Adds a query parameter to the URL
     * @param name An object of key-value pairs of the queries
     * @param [value] The value (if added)
     * @returns This instance to chain methods
     */
    query(name, value) {
        if (name instanceof Object) {
            for (const [key, val] of Object.entries(name))
                this.url.searchParams[key] = val;
        }
        else {
            this.url.searchParams[name] = value;
        }
        return this;
    }
    /**
     * Adds a header to the request
     * @param name An object of key-value pairs of the headers
     * @param value The value (if added)
     * @returns This instance to chain methods
     */
    header(name, value) {
        if (name instanceof Object) {
            for (const [key, val] of Object.entries(name))
                this.headers[key] = val;
        }
        else {
            this.header[name] = value;
        }
        return this;
    }
    /**
     * Sends data to the server
     * @param packet The data packet to send
     * @returns This instance to chain methods
     */
    body(packet) {
        this.data = figureData.apply(this, [packet]);
        return this;
    }
    /**
     * Sets a timeout to wait for
     * @param timeout The timeout to wait for
     * @returns This instance to chain methods
     */
    setTimeout(timeout) {
        if (isNaN(timeout))
            throw new Error('Timeout was not a number.');
        this.timeout = timeout;
        return this;
    }
    /**
     * If we should follow redirects
     * @returns This instance to chain methods
     */
    redirect() {
        this.followRedirects = true;
        return this;
    }
    then(resolve, reject) {
        return this.execute()
            .then(resolve, reject);
    }
    catch(callback) {
        return this.then(undefined, callback);
    }
    /**
     * Execute the request
     * @returns The response
     */
    execute() {
        const logger = this.client.middleware.get('logger');
        if (logger)
            logger.info(`Attempting to make a request to "${this.method.toUpperCase()} ${this.url}"`);
        const middleware = this.client.middleware.filter(middleware_1.CycleType.Execute);
        for (let i = 0; i < middleware.length; i++) {
            const ware = middleware[i];
            ware.intertwine.call(this.client);
        }
        return new Promise(async (resolve, reject) => {
            if (!this.headers.hasOwnProperty('user-agent'))
                this.headers['user-agent'] = this.client.userAgent;
            if (this.data) {
                if (this.data instanceof form_data_1.default) {
                    this.headers['content-type'] = this.data.getHeaders()['content-type'];
                }
                else if (isObject(this.data)) {
                    this.headers['content-type'] = 'application/json';
                }
            }
            const onRequest = async (res) => {
                if (this.client.middleware.has('streams')) {
                    this.streaming = this.client.middleware.get('streams');
                }
                if (this.client.middleware.has('compress')) {
                    this.compressData = this.client.middleware.get('compress');
                }
                const response = new HttpResponse_1.default(res, this.streaming, this._has('blob'));
                if (this.compressData) {
                    if (res.headers['content-encoding'] === 'gzip')
                        res.pipe(zlib_1.default.createGunzip());
                    if (res.headers['content-encoding'] === 'deflate')
                        res.pipe(zlib_1.default.createDeflate());
                }
                if (res.headers.hasOwnProperty('location') && this.followRedirects) {
                    const url = new url_1.URL(res.headers.location, this.url);
                    const req = new this.constructor(this.client, {
                        followRedirects: this.followRedirects,
                        compress: this.compressData,
                        timeout: this.timeout ? this.timeout : undefined,
                        headers: this.headers,
                        stream: this.streaming,
                        method: this.method,
                        data: this.data,
                        url
                    });
                    res.resume();
                    return resolve(await req.execute());
                }
                res.on('error', (error) => {
                    const httpError = new HttpError_1.default(1003, `Tried to serialise data, was unsuccessful (${error.message})`);
                    if (logger)
                        logger.error(`Tried to serialise data, was unsuccessful (${error.message})`);
                    return reject(httpError);
                });
                res.on('data', chunk => response.addChunk(chunk));
                res.on('end', () => {
                    if (!response.successful)
                        return reject(new HttpError_1.default(response.statusCode, response.status.replace(`${response.statusCode} `, '')));
                    else {
                        const middleware = this.client.middleware.filter(middleware_1.CycleType.Done);
                        for (let i = 0; i < middleware.length; i++) {
                            const ware = middleware[i];
                            ware.intertwine.call(this.client);
                        }
                        return resolve(response);
                    }
                });
            };
            const request = this.url.protocol === 'https:' ? https_1.default.request : http_1.default.request;
            const req = request({
                protocol: this.url.protocol,
                headers: this.headers,
                method: this.method,
                path: `${this.url.pathname}${this.url.search}`,
                port: this.url.port,
                host: this.url.hostname
            }, onRequest);
            if (this.timeout !== null) {
                setTimeout(() => {
                    if (req.aborted)
                        return;
                    req.abort();
                    return reject(new TimeoutError_1.default(this.url.toString(), this.timeout));
                }, this.timeout);
            }
            req.on('error', (error) => {
                const httpError = new HttpError_1.default(10004, `Unable to make a ${this.method.toUpperCase()} request to ${this.url} (${error.message})`);
                if (logger)
                    logger.error(`Unable to make a ${this.method.toUpperCase()} request to ${this.url} (${error.message})`);
                return reject(httpError);
            });
            if (this.data) {
                if (Array.isArray(this.data)) {
                    if (this.data.some(Buffer.isBuffer))
                        this.data.map(buf => req.write(buf));
                    else
                        req.write(JSON.stringify(this.data));
                }
                else if (typeof this.data === 'object' && !Array.isArray(this.data)) {
                    req.write(JSON.stringify(this.data));
                }
                else if (this.data instanceof Promise) {
                    req.write(await this.data);
                }
                else {
                    req.write(this.data);
                }
            }
            req.end();
        });
    }
}
exports.default = HttpRequest;
