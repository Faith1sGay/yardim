/**
 * Copyright (c) 2020-2021 August, Ice
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
import type * as types from '../types';
import * as Constants from '../Constants';
import GuildManager from '../managers/GuildManager';
import type Client from './WebSocketClient';
import EventBus from '../util/EventBus';
interface WebSocketShardEvents {
    close(id: number, error: Error, recoverable: boolean): void;
    ready(id: number, unavailable?: Set<string>): void;
    resume(id: number, replayed: number): void;
    debug(id: number, message: string): void;
    error(id: number, error: Error): void;
    disconnect(id: number): void;
    establish(id: number): void;
}
export default class WebSocketShard extends EventBus<WebSocketShardEvents> {
    /** The heartbeat interval to send out a [Heartbeat] packet to Discord */
    private _heartbeatInterval?;
    /** The reconnection timeout */
    private _reconnectTimeout?;
    /** The ready timeout */
    private _readyTimeout?;
    /** List of unavailable guilds known to this shard */
    unavailableGuilds: Set<string>;
    /** The last time we received an acked response */
    lastReceivedAt: number;
    /** The reconnect timeout to use */
    private reconnectTime;
    /** The session ID, this is populated when we receive a HELLO packet from Discord */
    private sessionID?;
    /** The last time we acked a response */
    lastAckedAt: number;
    /** The resolver function from [WebSocketShard._createConnection] */
    private resolver?;
    /** The rejecter function from [WebSocketShard._createConnection] */
    private rejecter?;
    /** The closing sequence number */
    closeSeq?: number;
    /** The serialization strategy to use when encoding/decoding packets */
    strategy: types.ClientOptions['strategy'];
    /** The [WebSocketClient] attached to this shard */
    private client;
    /** The status of the shard */
    status: 'connected' | 'handshaking' | 'nearly' | 'dead' | 'waiting_for_guilds';
    /** Guild cache for this shard, this is disabled if not provided. */
    guilds: GuildManager;
    /** If we acked a heartbeat response for not */
    private acked;
    /** The sequence number for resuming sessions */
    private seq;
    /** The actual WebSocket connection from Discord to us, initialised using [WebSocketShard.connect] */
    private ws;
    /** The shard's ID */
    id: number;
    /**
     * Gateway class to handle connections from Discord
     * @param client The [WebSocketClient] to attach
     * @param id The shard's ID
     * @param strategy The (de)serialization strategy to use
     */
    constructor(client: Client, id: number, strategy: types.ClientOptions['strategy']);
    /**
     * Returns the ping of this shard
     */
    get ping(): number;
    /**
     * Returns the serialization strategy to encode packets to Discord
     */
    get pack(): types.Serializable;
    /**
     * Returns the deserialization strategy to decode packets to Discord
     */
    get unpack(): types.Deserializable;
    debug(message: string): void;
    /**
     * Establishes a new connection with Discord, and connects to the gateway.
     */
    connect(): Promise<void>;
    /**
     * Disconnects from the gateway, if [reconnect] is `true` then spawn a new connection
     * @param reconnect If we should reconnect or not
     * @param closeCode The close code to send out if needed
     */
    disconnect(reconnect?: boolean, closeCode?: number): void;
    /**
     * Sends a packet to Discord
     * @param op The OPCode to use
     * @param data The optional data to use
     */
    send<T = unknown>(op: Constants.OPCodes, data?: T): void;
    /**
     * Sets the presence for this shard
     * @param status The status to use
     * @param options The options to use
     */
    setStatus(status: types.OnlineStatus, options: types.SendActivityOptions): void;
    _checkReady(): void;
    private _hardReset;
    private _identify;
    private _createConnection;
    private _serialize;
    private _onOpen;
    private _onClose;
    private _onError;
    private _onMessage;
    private _ackHeartbeat;
    private _resume;
    private _wsEvent;
    toString(): string;
}
export {};
