"use strict";
/**
 * Copyright (c) 2020-2021 August, Ice
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const models_1 = require("../models");
const Helper_1 = __importDefault(require("../interactions/Helper"));
const Constants = __importStar(require("../Constants"));
const ShardingManager_1 = __importDefault(require("./ShardingManager"));
const RestClient_1 = __importDefault(require("../rest/RestClient"));
const EventBus_1 = __importDefault(require("../util/EventBus"));
const util_1 = __importDefault(require("../util"));
const ChannelManager_1 = __importDefault(require("../managers/ChannelManager"));
const GuildManager_1 = __importDefault(require("../managers/GuildManager"));
const UserManager_1 = __importDefault(require("../managers/UserManager"));
/**
 * Handles everything related to Discord and is the entrypoint to your Discord bot.
 */
class WebSocketClient extends EventBus_1.default {
    /**
     * Handles everything related to Discord and is the entrypoint to your Discord bot.
     * @param options The options available to this context
     */
    constructor(options) {
        super();
        /** If we are ready to be used or not. */
        this.ready = false;
        this.voiceConnections = null;
        this.interactions = null;
        this.channels = new ChannelManager_1.default(this);
        this.options = util_1.default.merge(options, {
            populatePresences: false,
            allowedMentions: {
                everyone: false,
                replied: false,
                roles: false,
                users: false
            },
            reconnectTimeout: 7000,
            interactions: false,
            disabledEvents: [],
            getAllUsers: false,
            shardCount: 'auto',
            strategy: 'json',
            token: options.token,
            ws: {
                guildSubscriptions: true,
                largeThreshold: 250,
                connectTimeout: 30000,
                clientOptions: undefined,
                compress: false,
                intents: [],
                tries: undefined
            }
        });
        this.shards = new ShardingManager_1.default(this);
        this.guilds = new GuildManager_1.default(this);
        this.users = new UserManager_1.default(this);
        this.token = options.token;
        this.rest = new RestClient_1.default(this);
        this.once('ready', async () => {
            if (this.options.getAllUsers) {
                this.debug('Get All Users', 'Requesting all guild members...');
                await this.requestGuildMembers();
            }
            if (this.options.interactions) {
                this.debug('Interactions', 'Created interactions helper.');
                this.interactions = new Helper_1.default(this);
            }
        });
    }
    // Private Methods
    debug(title, message) {
        this.emit('debug', `[Debug => ${title}] ${message}`);
    }
    /**
     * Connects this [WebSocketClient] to the gateway
     */
    async connect() {
        const shardInfo = await this.getShardInfo();
        this.gatewayURL = `${shardInfo.url}/?v=${Constants.GatewayVersion}&encoding=${this.options.strategy}`;
        if (this.options.shardCount === 'auto')
            this.options.shardCount = shardInfo.shards;
        this.debug('Session Limit', shardInfo.session ? `${shardInfo.session.remaining}/${shardInfo.session.total}` : 'Not auto-sharding.');
        for (let i = 0; i < (this.options.shardCount === 1 ? 1 : this.options.shardCount - 1); i++) {
            await this.shards.spawn(i, this.options.strategy);
            await util_1.default.sleep(5000);
        }
    }
    /**
     * Returns the intents by it's numeric value
     */
    get intents() {
        if (typeof this.options.ws.intents === 'undefined')
            return Constants.GatewayIntents.guilds | Constants.GatewayIntents.guildMessages;
        else if (typeof this.options.ws.intents === 'number')
            return this.options.ws.intents;
        else {
            let intents = 0;
            for (let i = 0; i < this.options.ws.intents.length; i++) {
                const intent = this.options.ws.intents[i];
                if (typeof intent === 'number') {
                    intents |= intent;
                }
                else {
                    if (!Constants.GatewayIntents.hasOwnProperty(intent))
                        continue;
                    intents |= Constants.GatewayIntents[intent];
                }
            }
            return intents;
        }
    }
    /**
     * Returns the bot's gateway information
     */
    getBotGateway() {
        return this.rest.dispatch({
            endpoint: '/gateway/bot',
            method: 'get'
        });
    }
    /**
     * Returns the gateway information
     */
    getGateway() {
        return this.rest.dispatch({
            endpoint: '/gateway',
            method: 'get'
        });
    }
    /**
     * Returns the shard information
     */
    async getShardInfo() {
        const data = this.options.shardCount === 'auto' ?
            await this.getBotGateway() :
            await this.getGateway();
        if (!data.url || (this.options.shardCount === 'auto' && !data.shards))
            throw new TypeError('Unable to retrieve shard information');
        const session = data.hasOwnProperty('session_start_limit') ? data.session_start_limit : undefined;
        if (session !== undefined && session.remaining <= 0) {
            const error = new Error('Exceeded the amount of tries to connect');
            this.emit('error', error);
            return Promise.reject(error);
        }
        return {
            session,
            shards: this.options.shardCount === 'auto' ? data.shards : this.options.shardCount,
            url: data.url
        };
    }
    async requestGuildMembers() {
        if (!(this.intents & Constants.GatewayIntents.guildMembers)) {
            this.debug('Get Guild Members', 'Missing `guildMembers` intent, skipping');
            return;
        }
        const promises = this.guilds.cache.map(guild => {
            if (!guild.unavailable) {
                if (this.options.populatePresences && !(this.intents & Constants.GatewayIntents.guildPresences)) {
                    this.debug('Get Guild Members | Populate Presences', 'Missing `guildPresences` intent');
                    this.options.populatePresences = false;
                }
                return guild.fetchMembers({
                    limit: guild.maxMembers,
                    presences: this.options.populatePresences,
                    query: '',
                    time: 120e3,
                    nonce: Date.now().toString(16),
                    force: false,
                    ids: []
                });
            }
            else {
                return Promise.resolve(null);
            }
        });
        await Promise.all(promises).then(members => {
            if (members === null)
                return;
            members.map(collection => {
                if (!collection)
                    return;
                this.debug('Get Guild Members', `Populating ${collection.size} members if possible...`);
                for (const member of collection.values()) {
                    const user = new models_1.User(this, member.user);
                    this.users.add(user);
                }
            });
        });
    }
    disconnect(reconnect = false) {
        if (reconnect) {
            this.debug('End Of Life', 'Reconnecting all shards to Discord...');
            for (const shard of this.shards.values())
                shard.disconnect(true);
            return;
        }
        this.debug('End Of Life', 'Disconnecting from Discord...');
        this.channels.cache.clear();
        this.guilds.cache.clear();
        this.users.cache.clear();
        for (const shard of this.shards.values())
            shard.disconnect(false);
    }
    setStatus(status, options) {
        for (const shard of this.shards.values())
            shard.setStatus(status, options);
    }
}
exports.default = WebSocketClient;
