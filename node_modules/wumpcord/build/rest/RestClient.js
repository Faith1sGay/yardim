"use strict";
/**
 * Copyright (c) 2020-2021 August, Ice
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const orchid_1 = require("@augu/orchid");
const DiscordRestValidationError_1 = __importDefault(require("../errors/DiscordRestValidationError"));
const DiscordRestError_1 = __importDefault(require("../errors/DiscordRestError"));
const DiscordAPIError_1 = __importDefault(require("../errors/DiscordAPIError"));
const RatelimitBucket_1 = __importDefault(require("./RatelimitBucket"));
const Constants = __importStar(require("../Constants"));
const collections_1 = require("@augu/collections");
const form_data_1 = __importDefault(require("form-data"));
const util_1 = __importDefault(require("../util"));
/**
 * Represents a class to handle requests to Discord
 */
class RestClient {
    /**
     * Represents a class to handle requests to Discord
     * @param client The client to use
     */
    constructor(client) {
        /** The last time the rest client has dispatched a request (when [RestClient.dispatch] was called) */
        this.lastDispatchedAt = -1;
        /** If we are being ratelimited or not */
        this.ratelimited = false;
        /** The last rest call from Discord (when we receive a payload from [RestClient._handleRequest]) */
        this.lastCallAt = -1;
        this.lastDispatchedAt = -1;
        this.ratelimited = false;
        this.lastCallAt = -1;
        this.requests = new collections_1.Queue();
        this.client = client;
        this.locked = false;
        this.http = new orchid_1.HttpClient({
            middleware: [orchid_1.middleware.forms()],
            defaults: {
                baseUrl: `${Constants.RestUrl}/v${Constants.RestVersion}`,
                headers: {
                    Authorization: `Bot ${client.token}`,
                    'User-Agent': Constants.UserAgent
                }
            }
        });
    }
    /**
     * Gets the current ping of the rest client
     */
    get ping() {
        return this.lastDispatchedAt === -1 ? -1 : (this.lastCallAt - this.lastDispatchedAt);
    }
    /**
     * If the rest client is busy or not
     */
    get busy() {
        // @ts-ignore
        return this.requests.items.length !== 0;
    }
    /**
     * Dispatch a request to Discord
     * @param options The request options
     */
    dispatch(options) {
        return new Promise((resolve, reject) => {
            const request = {
                resolve,
                reject,
                headers: util_1.default.get(options, 'headers', {}),
                endpoint: options.endpoint,
                method: options.method,
                data: util_1.default.get(options, 'data', undefined),
                file: util_1.default.get(options, 'file', undefined)
            };
            this._executeRequest(request)
                .then((data) => {
                this.lastDispatchedAt = Date.now();
                return resolve(data);
            }).catch((error) => {
                this.lastDispatchedAt = Date.now();
                return reject(error);
            });
        });
    }
    /**
     * Executes the request and handles ratelimiting
     * @param request The dispatched requeest
     */
    async _executeRequest(request) {
        const bucket = new RatelimitBucket_1.default();
        let form = undefined;
        if (!['get', 'GET', 'head', 'HEAD'].includes(request.method) && !request.headers.hasOwnProperty('Content-Type'))
            request.headers['Content-Type'] = 'application/json';
        if (request.auditLogReason !== undefined)
            request.headers['X-Audit-Log-Reason'] = encodeURIComponent(request.auditLogReason);
        if (request.file) {
            form = new form_data_1.default();
            if (Array.isArray(request.file)) {
                for (let i = 0; i < request.file.length; i++) {
                    const file = request.file[i];
                    if (!file.name)
                        file.name = 'file.png';
                    form.append(file.name, file.file, { filename: file.name });
                }
            }
            else {
                if (!request.file.name)
                    request.file.name = 'file.png';
                form.append(request.file.name, request.file.file, { filename: request.file.name });
            }
            if (request.data)
                form.append('payload_json', JSON.stringify(request.data), { filename: 'payload_json' });
            request.headers['Content-Type'] = form.getHeaders();
        }
        return new Promise((resolve, reject) => this.http.request({
            method: request.method,
            url: request.endpoint,
            data: form ? form.getBuffer() : request.data,
            headers: request.headers
        }).then(async (res) => {
            if (res.statusCode !== 204 && res.isEmpty) {
                this.client.debug('RestClient', 'Received a empty body from Discord, did we fuck up? (https://github.com/auguwu/Wumpcord/issues)');
                /**
                 * Emitted when we receive a empty body payload
                 * @fires restEmpty
                 */
                this.client.emit('restEmpty');
                this.lastCallAt = Date.now();
                return resolve(null);
            }
            this.lastCallAt = Date.now();
            if (res.statusCode === 204)
                return resolve(null);
            const ratelimitInfo = await bucket.handle(request.endpoint, res);
            const data = res.json();
            if (ratelimitInfo.ratelimited) {
                this.ratelimited = true;
                await util_1.default.sleep(Number(res.headers['retry-after']));
                return resolve(null);
            }
            // sometimes cloudflare can be mean >:(
            if (res.statusCode === 502) {
                /**
                 * Fired when Discord or Cloudflare stop working
                 * @fires restUnavailable
                 */
                this.client.emit('restUnavailable');
                return reject(new DiscordAPIError_1.default(502, 'Gateway is unavailable at this time (https://discordstatus.com)'));
            }
            /**
             * Fired when the rest call has succeeded or errored out
             * @fires restCall
             * @param properties The properties available
             */
            this.client.emit('restCall', {
                ratelimitInfo,
                successful: res.successful,
                endpoint: request.endpoint,
                method: request.method,
                body: res.text(),
                ping: this.ping
            });
            if (data.hasOwnProperty('code')) {
                if (data.hasOwnProperty('errors')) {
                    const errors = [];
                    for (const key of Object.keys(data.errors)) {
                        const error = (data.errors[key]?._errors ?? []).map(d => ({ ...d, key }));
                        if (error.length > 0)
                            errors.push(...error);
                    }
                    return reject(new DiscordRestValidationError_1.default(request.endpoint, request.method, data.code, data.message, errors));
                }
                else {
                    return reject(new DiscordRestError_1.default(data.code, data.message));
                }
            }
            else {
                return resolve(data);
            }
        }).catch((ex) => reject(new DiscordAPIError_1.default(ex.statusCode || 500, ex.message))));
    }
}
exports.default = RestClient;
