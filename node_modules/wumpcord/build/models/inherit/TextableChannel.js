"use strict";
/**
 * Copyright (c) 2020-2021 August, Ice
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ChannelMessagesManager_1 = __importDefault(require("../../managers/ChannelMessagesManager"));
const Constants_1 = require("../../Constants");
const Message_1 = require("../Message");
const Channel_1 = require("../Channel");
const Permissions_1 = __importDefault(require("../../util/Permissions"));
const util_1 = __importDefault(require("../../util"));
const Webhook_1 = require("../Webhook");
class TextableChannel extends Channel_1.Channel {
    constructor(client, data) {
        super(data);
        this.messages = new ChannelMessagesManager_1.default(client);
        this.client = client;
    }
    bulkDelete(messages) {
        if (!Array.isArray(messages))
            throw new TypeError('Expected a list of messages or messages IDs');
        if (messages.some(val => typeof val !== 'string' || !(val instanceof Message_1.Message)))
            throw new TypeError('Some messages were not a string of message IDs or instances of \`Message\`.');
        const bulk = messages.map(val => val instanceof Message_1.Message ? val.id : val);
        if (!bulk.length)
            return Promise.resolve(0);
        if (bulk.length === 1) {
            return this.client.rest.dispatch({
                endpoint: `/channels/${this.id}/messages/${bulk[0]}`,
                method: 'DELETE'
            }).then(() => 1);
        }
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.id}/messages/bulk-delete`,
            method: 'POST',
            data: {
                messages: bulk
            }
        }).then(() => bulk.length);
    }
    getMessages(amount, options) {
        if (isNaN(amount))
            throw new TypeError(`Amount "${amount}" was not a number`);
        if (amount < 2 || amount > 100)
            throw new TypeError('The amount must be lower/equal to 2 or higher/equal to 100');
        const query = util_1.default.objectToQuery({
            limit: amount,
            ...(options !== undefined ? options : {})
        });
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.id}/messages${query}`,
            method: 'GET'
        }).then(data => data.map(val => new Message_1.Message(this.client, val)));
    }
    sendTyping() {
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.id}/typing`,
            method: 'POST'
        });
    }
    getPins() {
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.id}/messages/pins`,
            method: 'GET'
        }).then(data => data.map(val => new Message_1.Message(this.client, val)));
    }
    permissionsOf(memberID) {
        const self = this;
        if (!self.guild)
            throw new TypeError(`TextableChannel "${this.constructor.name}" is not a Guild channel.`);
        const guild = self.guild;
        const member = self.guild.members.get(memberID);
        if (member === null)
            return new Permissions_1.default('0');
        let permission = member.permission.allow;
        if (permission & Constants_1.Permissions.administrator)
            return new Permissions_1.default(String(Constants_1.Permissions.all));
        let overwrite = this.permissionOverwrites.get(guild?.id ?? self.guildID);
        if (overwrite)
            permission = (permission & ~overwrite.permissions.denied) | overwrite.permissions.allow;
        let deny = 0;
        let allow = 0;
        for (const roleID of member.roles.keys()) {
            if ((overwrite = self.permissionOverwrites.get(roleID)) !== undefined) {
                deny |= overwrite.permissions.denied;
                allow |= overwrite.permissions.allow;
            }
        }
        permission = (permission & ~deny) | allow;
        overwrite = self.permissionOverwrites.get(memberID);
        if (overwrite !== undefined)
            permission = (permission & ~overwrite.permissions.denied) | overwrite.permissions.allow;
        return new Permissions_1.default(String(permission));
    }
    getWebhooks() {
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.id}/webhooks`,
            method: 'GET'
        }).then(webhooks => webhooks.map(d => new Webhook_1.Webhook(this.client, d)));
    }
    send(content, options) {
        const data = util_1.default.formatMessage(this.client, content, options);
        const file = data.file;
        delete data.file;
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.id}/messages`,
            method: 'POST',
            file,
            data
        }).then(d => new Message_1.Message(this.client, d));
    }
}
exports.default = TextableChannel;
