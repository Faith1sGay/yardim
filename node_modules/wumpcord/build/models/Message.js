"use strict";
/**
 * Copyright (c) 2020-2021 August, Ice
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = void 0;
const _1 = require(".");
const User_1 = require("./User");
const Base_1 = __importDefault(require("./Base"));
const util_1 = __importDefault(require("../util"));
class Message extends Base_1.default {
    constructor(client, data) {
        super(data.id);
        this.client = client;
        this.edits = [];
        this.patch(data);
    }
    patch(data) {
        if (data.edited_timestamp !== undefined)
            this.editedTimestamp = data.edited_timestamp !== null ? new Date(data.edited_timestamp) : null;
        if (data.mention_channels !== undefined)
            this.mentionChannels = data.mention_channels.map(c => c.id);
        if (data.mention_everyone !== undefined)
            this.mentionEveryone = data.mention_everyone;
        if (data.mention_roles !== undefined)
            this.mentionRoles = data.mention_roles;
        if (data.message_reference !== undefined)
            this.reference = data.message_reference;
        if (data.channel_id !== undefined)
            this.channelID = data.channel_id;
        if (data.mentions !== undefined)
            this.mentions = data.mentions.map(r => r.id);
        if (data.guild_id !== undefined)
            this.guildID = data.guild_id;
        if (data.member !== undefined)
            this.member = new _1.GuildMember(this.client, data.member);
        if (data.embeds !== undefined)
            this.embeds = data.embeds;
        if (data.author !== undefined)
            this.author = this.client.users.add(new User_1.User(this.client, data.author));
        if (data.flags !== undefined)
            this.flags = data.flags;
        if (data.tts !== undefined)
            this.tts = data.tts;
        if (data.timestamp !== undefined)
            this.timestamp = new Date(data.timestamp);
        if (data.reactions !== undefined)
            this.reactions = data.reactions;
        if (data.pinned !== undefined)
            this.pinned = data.pinned;
        if (data.webhook_id !== undefined)
            this.webhookID = data.webhook_id;
        if (data.type !== undefined)
            this.type = data.type;
        if (data.activity !== undefined)
            this.activity = data.activity;
        if (data.application !== undefined)
            this.application = data.application;
        if (data.content !== undefined)
            this.content = data.content;
        if (data.referenced_message !== undefined)
            this.referencedMessage = data.referenced_message !== null ? new Message(this.client, data.referenced_message) : null;
        this.edits.unshift(this);
    }
    get edited() {
        return this.edits[this.edits.length - 1] ?? null;
    }
    get guild() {
        return this.client.guilds.get(this.guildID);
    }
    get channel() {
        return this.client.channels.get(this.channelID);
    }
    delete() {
        const channelID = this.channel !== null ? this.channel.id : this.channelID;
        return this.client.rest.dispatch({
            endpoint: `/channels/${channelID}/messages/${this.id}`,
            method: 'DELETE'
        });
    }
    crosspost() {
        const channel = this.channel !== null ? this.channel.id : this.channelID;
        return this.client.rest.dispatch({
            endpoint: `/channels/${channel}/messages/${this.id}/crosspost`,
            method: 'POST'
        }).then(data => new Message(this.client, data));
    }
    react(reaction) {
        let emote;
        if (reaction instanceof _1.GuildEmoji)
            emote = `:${reaction.name}:${reaction.id}`;
        else if (reaction === decodeURI(reaction))
            emote = reaction;
        else if (reaction.startsWith(':'))
            emote = reaction;
        else
            throw new TypeError('Emojis must be encoded as `:name:id`');
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.channelID}/messages/${this.id}/reactions/${emote}/@me`,
            method: 'PUT'
        });
    }
    unreact(reaction) {
        let emote;
        if (reaction instanceof _1.GuildEmoji)
            emote = `:${reaction.name}:${reaction.id}`;
        else if (reaction === decodeURI(reaction))
            emote = reaction;
        else if (reaction.startsWith(':'))
            emote = reaction;
        else
            throw new TypeError('Emojis must be encoded as `:name:id`');
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.channelID}/messages/${this.id}/reactions/${emote}/@me`,
            method: 'DELETE'
        });
    }
    getReactions(reaction, opts) {
        if (opts !== undefined && !util_1.default.isObject(opts))
            throw new TypeError(`Expected \`object\`, but received ${typeof opts}`);
        const options = util_1.default.merge(opts, { limit: 100 });
        if (options.before && typeof options.before !== 'string')
            throw new TypeError(`Expected \`string\`, but received ${typeof options.before}`);
        if (options.after && typeof options.after !== 'string')
            throw new TypeError(`Expected \`string\`, but received ${typeof options.after}`);
        if (options.limit) {
            if (typeof options.limit !== 'number')
                throw new TypeError(`Expected \`number\`, but gotten ${typeof options.limit}`);
            if (options.limit < 2 || options.limit > 100)
                throw new RangeError('Limit of reactions must be 2-100.');
        }
        let emote;
        if (reaction instanceof _1.GuildEmoji)
            emote = reaction.id;
        else {
            if (reaction === decodeURI(reaction))
                emote = reaction;
        }
        const url = `/channels/${this.channelID}/messages/${this.id}/reactions/${emote}/@me${util_1.default.objectToQuery(options)}`;
        return this.client.rest.dispatch({
            endpoint: url,
            method: 'GET'
        }).then(users => users.map(d => new User_1.User(this.client, d)));
    }
    deleteReactions() {
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.channelID}/messages/${this.id}/reactions`,
            method: 'DELETE'
        });
    }
    edit(content, options) {
        const data = util_1.default.formatMessage(this.client, content, options);
        if (data.file !== undefined)
            delete data.file;
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.channelID}/messages/${this.id}`,
            method: 'PATCH',
            data
        }).then(data => new Message(this.client, data));
    }
    reply(content, options) {
        let message = {
            reply: this.id
        };
        if (typeof content === 'string') {
            const data = util_1.default.formatMessage(this.client, {
                reply: this.id,
                content: content
            });
            return this.client.rest.dispatch({
                endpoint: `/channels/${this.channelID}/messages`,
                method: 'POST',
                data
            }).then(data => new Message(this.client, data));
        }
        if (util_1.default.isObject(content) && util_1.default.isObject(options))
            throw new Error('Cannot have `content` and `options` as message options');
        if (util_1.default.isObject(content))
            message = { reply: this.id, ...content };
        if (util_1.default.isObject(options))
            message = { reply: this.id, ...options };
        const data = util_1.default.formatMessage(this.client, message);
        let file = data.file;
        delete data.file;
        console.log(data);
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.channelID}/messages`,
            method: 'POST',
            data,
            file
        }).then(data => new Message(this.client, data));
    }
    pin() {
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.id}/pins/${this.id}`,
            method: 'PUT'
        });
    }
    unpin() {
        return this.client.rest.dispatch({
            endpoint: `/channels/${this.id}/pins/${this.id}`,
            method: 'DELETE'
        });
    }
}
exports.Message = Message;
